using System;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Web.Mvc;
using FluentValidation.Validators;
using System.ComponentModel;
using System.Collections.Generic;
using Higgs.Core.Helpers;
using Higgs.Core.Model;
using Higgs.Core.Validation;
using Higgs.Web.Helpers;
using FluentValidation.Resources;

namespace Higgs.Web
{
    public static class ModelSerializer
    {
        private static int OrderByTypeHierarchy(Type modelType, Type propertyDeclearingType)
        {
            if (modelType == propertyDeclearingType)
                return 0;

            var result = 0;
            do
            {
                propertyDeclearingType = propertyDeclearingType.BaseType;

                if(propertyDeclearingType != null && propertyDeclearingType != modelType)
                {
                    result++;
                }
            } while (propertyDeclearingType != null && propertyDeclearingType.BaseType != null);

            return result;
        }

        public static void SerializeModel<T>(this HtmlHelper<T> helper)
        {
            SerializeModel(helper.ViewData.Model);
        }

        public static void SerializeModel<T>(T model)
        {
            if(HiggsScriptManager.SerializedType == null)
            {
                HiggsScriptManager.SerializedType = new List<Type>();
            }

            HiggsScriptManager.InsertScript(null, "__" + model.GetType().Name, SerializeModel(model, null));
            HiggsScriptManager.SerializedType.Add(model.GetType());
        }

        private static readonly object _lockObj = new object();
        private static readonly List<Type> CacheTypes = new List<Type>();
        private static readonly Dictionary<PropertyInfo, DefaultValueAttribute> _defaultAttributeCache = new Dictionary<PropertyInfo, DefaultValueAttribute>();
        public static string SerializeModel<T>(T model, string variableName, Dictionary<string, Action<StringBuilder, object>> customPropertyValueProvider = null)
        {
            var propertySelectableModel = model as IPropertySelectable;
            var sb = new StringBuilder();
            var modelType = typeof(T);
            var dataType = model.GetType();
            var modelName = "$" + ((!string.IsNullOrEmpty(variableName)) ? variableName : modelType.Name);
            var commaWithNewLine = "," + Environment.NewLine;

            sb.Add("{0} = window.{0} = {{}};", modelName);

            var properties = modelType.GetProperties().OrderByDescending(x => OrderByTypeHierarchy(modelType, x.DeclaringType));
            var validatorInstance = MvcApplication.HiggsValidatorProvider.GetValidators(dataType).ToList();
            var propertyValidators = ValidationHelper.GetPropertyValidator(dataType, validatorInstance);

            if(!CacheTypes.Contains(modelType)) CacheDefaultValueAttribute(modelType, properties);
            
            foreach (var pi in properties)
            {
                var hasObject = false;
                var isCustomPropertyValue = customPropertyValueProvider != null && customPropertyValueProvider.ContainsKey(pi.Name);
                
                if (
                        ((propertySelectableModel != null && (modelType == pi.DeclaringType || propertySelectableModel.IsSelectedProperty(pi.Name))) || propertySelectableModel == null) && 
                        pi.CanRead && 
                        pi.CanWrite &&
                        (pi.PropertyType.Namespace == "System" || isCustomPropertyValue)
                   )
                {
                    sb.AppendFormat("{0}.{1} = ", modelName, pi.Name);
                    var beforeInsertObjectIndex = sb.Length;
                    sb.Add("");
                    sb.Add("{");
                    
                    object objectValue = null;
                    
                    try
                    {
                        objectValue = pi.GetValue(model, null);
                    }
                    catch { }
                    
                    if (objectValue != null)
                    {
                        if(isCustomPropertyValue)
                        {
                            sb.Append("\tvalue : ");
                            customPropertyValueProvider[pi.Name](sb, objectValue);
                            sb.AppendLine(",");

                            hasObject = true;
                        }
                        else
                        {
                            var value = GetValue(pi, objectValue);

                            if (!string.IsNullOrEmpty(value))
                            {
                                sb.Add("\tvalue : {0},", value);

                                hasObject = true;
                            }
                        }
                    }

                    if (_defaultAttributeCache.ContainsKey(pi))
                    {
                        sb.Add("\tdefaultValue : {0},", GetValue(pi, _defaultAttributeCache[pi].Value));
                        hasObject = true;
                    }

                    var beforeInsertRuleIndex = sb.Length;
                    var propertyRules = propertyValidators.ContainsKey(pi.Name) ? propertyValidators[pi.Name] : null;

                    sb.Add("\trules : ");

                    sb.Add("\t[");

                    var hasRule = false;
                    if(_customRules.ContainsKey(pi.PropertyType))
                    {
                        hasRule = true;
                        sb.Add(_customRules[pi.PropertyType]);
                    }

                    if (propertyRules != null)
                    {
                        hasRule |= GenerateRule(propertyRules, sb, modelName);
                    }
                    else if(hasRule)
                    {
                        sb = sb.Remove(sb.Length - 3, 3);
                        sb.Add();
                    }
                    sb.Add("\t]");

                    if (!hasRule)
                    {
                        sb.Remove(beforeInsertRuleIndex, sb.Length - beforeInsertRuleIndex);
                    }
                    else
                    {
                        hasObject = true;
                    }

                    if(sb.ToString().EndsWith(commaWithNewLine))
                    {
                        sb.Remove(sb.Length - commaWithNewLine.Length, 1);
                    }

                    sb.Add("};");
                    
                    if (!hasObject)
                    {
                        sb.Remove(beforeInsertObjectIndex, sb.Length - beforeInsertObjectIndex);
                        sb.Add("{};");
                    }
                }
            }

            var mappingRule = ValidationHelper.GetRuleMapping<T>(validatorInstance);
            foreach (var keyValuePair in mappingRule)
            {
                sb.Add("mapValidationRule({0}.{1}, {0}.{2});", modelName, keyValuePair.Key, keyValuePair.Value);
            }

            sb.Add();
            sb.Add("higgs.processModel({0});", modelName);

            return sb.ToString();
        }

        private static void CacheDefaultValueAttribute(Type t, IEnumerable<PropertyInfo> properties)
        {
            lock (_lockObj)
            {
                var defaultValue = typeof (DefaultValueAttribute);

                foreach (var p in properties)
                {
                    var temp = p.GetCustomAttributes(defaultValue, true);

                    if (temp.Length > 0)
                    {
                        _defaultAttributeCache.Add(p, (DefaultValueAttribute) temp[0]);
                    }
                }

                CacheTypes.Add(t);
            }
        }

        private static string GetValue(PropertyInfo pi, object obj)
        {
            if (pi.PropertyType == typeof(bool) || pi.PropertyType == typeof(bool?))
            {
                return obj.ToString().ToLower();
            }
            if(pi.PropertyType == typeof(DateTime) || pi.PropertyType == typeof(DateTime?))
            {
                return "'" + ((DateTime)obj).ToLongTimeString() + "'";
            }

            if (pi.PropertyType == typeof(Guid) || pi.PropertyType == typeof(Guid?))
            {
                var temp = obj.ToString();

                if (temp == "00000000-0000-0000-0000-000000000000") return "emptyGuid";
            }

            return obj.ToEscapeString();
        }

        private static readonly Dictionary<Type, string> _customRules = new Dictionary<Type, string>
        {
            {typeof(byte), string.Format("\t\t\tnew rangeValidation({0}, {1}),", byte.MinValue, byte.MaxValue)},
            {typeof(byte?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", byte.MinValue, byte.MaxValue)},
            {typeof(Int16), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Int16.MinValue, Int16.MaxValue)},                      
            {typeof(Int16?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Int16.MinValue, Int16.MaxValue)},                      
            {typeof(Int32), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Int32.MinValue, Int32.MaxValue)},                      
            {typeof(Int32?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Int32.MinValue, Int32.MaxValue)},                      
            {typeof(Int64), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Int64.MinValue, Int64.MaxValue)},                      
            {typeof(Int64?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Int64.MinValue, Int64.MaxValue)},                      
            {typeof(SByte), string.Format("\t\t\tnew rangeValidation({0}, {1}),", SByte.MinValue, SByte.MaxValue)},                      
            {typeof(SByte?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", SByte.MinValue, SByte.MaxValue)},                      
            {typeof(UInt16), string.Format("\t\t\tnew rangeValidation({0}, {1}),", UInt16.MinValue, UInt16.MaxValue)},                      
            {typeof(UInt16?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", UInt16.MinValue, UInt16.MaxValue)},                      
            {typeof(UInt32), string.Format("\t\t\tnew rangeValidation({0}, {1}),", UInt32.MinValue, UInt32.MaxValue)},                      
            {typeof(UInt32?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", UInt32.MinValue, UInt32.MaxValue)},                      
            {typeof(UInt64), string.Format("\t\t\tnew rangeValidation({0}, {1}),", UInt64.MinValue, UInt64.MaxValue)},                      
            {typeof(UInt64?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", UInt64.MinValue, UInt64.MaxValue)},                      
            {typeof(Decimal), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Decimal.MinValue, Decimal.MaxValue)},                      
            {typeof(Decimal?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Decimal.MinValue, Decimal.MaxValue)},                      
            {typeof(Double), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Double.MinValue, Double.MaxValue)},                      
            {typeof(Double?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Double.MinValue, Double.MaxValue)},                      
            {typeof(Single), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Single.MinValue, Single.MaxValue)},                      
            {typeof(Single?), string.Format("\t\t\tnew rangeValidation({0}, {1}),", Single.MinValue, Single.MaxValue)}               
        };

        private static bool GenerateRule(IEnumerable<IPropertyValidator> rules, StringBuilder sb, string modelName)
        {
            var hasRule = false;

            foreach(var r in rules)
            {
                var validationType = r.GetType();

                if (typeof(INotNullValidator).IsAssignableFrom(validationType))
                {
                    hasRule = true;
                    sb.Append("\t\t\tnew requiredValidation()");
                }
                else if (typeof(INotEmptyValidator).IsAssignableFrom(validationType))
                {
                    hasRule = true;
                    sb.Append("\t\t\tnew notEmptyValidation()");
                }
                else if (typeof(ILengthValidator).IsAssignableFrom(validationType))
                {
                    hasRule = true;
                    var lengthValidator = (ILengthValidator)r;
                    sb.AppendFormat("\t\t\tnew stringLengthValidation({0}, {1})", lengthValidator.Min, lengthValidator.Max);
                }
                else if (typeof(IEmailValidator).IsAssignableFrom(validationType))
                {
                    hasRule = true;
                    sb.AppendFormat("\t\t\tnew emailValidation()");
                }
                else if (typeof(IRegularExpressionValidator).IsAssignableFrom(validationType))
                {
                    hasRule = true;
                    var regexValidator = (IRegularExpressionValidator)r;
                    sb.AppendFormat("\t\t\tnew regularExpressionValidation('{0}')", regexValidator.Expression);
                }
                else if (typeof(IComparisonValidator).IsAssignableFrom(validationType))
                {
                    hasRule = true;
                    var v = (IComparisonValidator)r;

                    switch (v.Comparison)
                    {
                        case Comparison.Equal:
                            sb.AppendFormat("\t\t\tnew equalValidation({0})", v.ValueToCompare != null ? "'" + v.ValueToCompare + "'" : modelName + "." + v.MemberToCompare.Name);
                            break;
                    }
                }
                else if (typeof(ICollectionCountValidator).IsAssignableFrom(validationType))
                {
                    hasRule = true;
                    var v = (ICollectionCountValidator)r;

                    if (v.Max == int.MaxValue)
                    {
                        sb.AppendFormat("\t\t\tnew collectionCountValidation({0})", v.Min);
                    }
                    else
                    {
                        sb.AppendFormat("\t\t\tnew collectionCountValidation({0}, {1})", v.Min, v.Max);
                    }
                }
                else
                {
                    hasRule |= false;
                    continue;
                }

                if ((r.ErrorMessageSource is LocalizedStringSource && ((LocalizedStringSource)r.ErrorMessageSource).ResourceType != typeof(Messages)) || r.ErrorMessageSource is StaticStringSource)
                {
                    // TODO: 1.0 - Support CustomMessageFormatArguments
                    sb.Add(".errorMsg({0}),", r.ErrorMessageSource.GetString().ToEscapeString());
                }
                else
                {
                    sb.Add(",");
                }
            }

            if (hasRule)
            {
                sb = sb.Remove(sb.Length - 3, 3);
                sb.Add();

                return true;
            }

            return false;
        }
    }
}
